"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2272],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=o.createContext({}),s=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=s(e.components);return o.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=s(n),u=i,g=d["".concat(p,".").concat(u)]||d[u]||c[u]||a;return n?o.createElement(g,r(r({ref:t},m),{},{components:n})):o.createElement(g,r({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<a;s++)r[s]=n[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4094:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return c}});var o=n(7462),i=n(3366),a=(n(7294),n(3905)),r=["components"],l={slug:"argocd-commit-pinning",title:"Production Release With Argo CD - Commit Pinning",description:"Gitploy provides another solution deploying to multiple environments.",tags:["GitHub Action","Argo CD","Commit Pinning"],image:"./demo.gif",keywords:["argocd","argo-cd","commit pinning","deployment strategy"]},p=void 0,s={permalink:"/blog/argocd-commit-pinning",editUrl:"https://github.com/gitploy-io/website/tree/main/blog/2022-06-21-argocd-commit-pinning/index.md",source:"@site/blog/2022-06-21-argocd-commit-pinning/index.md",title:"Production Release With Argo CD - Commit Pinning",description:"Gitploy provides another solution deploying to multiple environments.",date:"2022-06-21T00:00:00.000Z",formattedDate:"June 21, 2022",tags:[{label:"GitHub Action",permalink:"/blog/tags/git-hub-action"},{label:"Argo CD",permalink:"/blog/tags/argo-cd"},{label:"Commit Pinning",permalink:"/blog/tags/commit-pinning"}],readingTime:3.71,truncated:!1,authors:[],frontMatter:{slug:"argocd-commit-pinning",title:"Production Release With Argo CD - Commit Pinning",description:"Gitploy provides another solution deploying to multiple environments.",tags:["GitHub Action","Argo CD","Commit Pinning"],image:"./demo.gif",keywords:["argocd","argo-cd","commit pinning","deployment strategy"]},nextItem:{title:"Deploy to multiple environments with GitHub Action",permalink:"/blog/deploy-to-multi-envs"}},m={image:n(4093).Z,authorsImageUrls:[]},c=[{value:"Deployment Strategy of Argo CD",id:"deployment-strategy-of-argo-cd",level:2},{value:"Commit Pinning By CLI",id:"commit-pinning-by-cli",level:2},{value:"Integration With Argo CD",id:"integration-with-argo-cd",level:2}],d={toc:c};function u(e){var t=e.components,l=(0,i.Z)(e,r);return(0,a.kt)("wrapper",(0,o.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"deployment-strategy-of-argo-cd"},"Deployment Strategy of Argo CD"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://argo-cd.readthedocs.io/en/stable/"},"Argo CD")," is the most popular\xa0GitOps tool for Kubernetes. Argo CD makes it easy to define an application with its desired state in a repository and where it should be deployed. After a deployment, ",(0,a.kt)("strong",{parentName:"p"},"Argo CD constantly tracks updates to branches, tags, or pinned to a specific version of manifests at a Git commit.")),(0,a.kt)("p",null,"Argo CD provides ",(0,a.kt)("a",{parentName:"p",href:"https://argo-cd.readthedocs.io/en/stable/user-guide/tracking_strategies/"},"several different ways")," of tracking Kubernetes resource manifests. Among them, ",(0,a.kt)("strong",{parentName:"p"},"commit pinning is typically used to control production environments.")," Since commit SHAs cannot change the meaning, the live state of an application can be fixed and predictable. So the application remains stable."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"HEAD / Branch Tracking"),(0,a.kt)("li",{parentName:"ul"},"Tag Tracking"),(0,a.kt)("li",{parentName:"ul"},"Commit Pinning")),(0,a.kt)("h2",{id:"commit-pinning-by-cli"},"Commit Pinning By CLI"),(0,a.kt)("p",null,"Now, we'll deploy the manifest in a specific commit from the Argo CD. First, before starting the demo, install the ",(0,a.kt)("inlineCode",{parentName:"p"},"argocd")," command. More detailed installation instructions can be found via the CLI ",(0,a.kt)("a",{parentName:"p",href:"https://argo-cd.readthedocs.io/en/stable/cli_installation/"},"installation documentation"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gitploy-io/argocd-demo"},"repository")," to be used as a demo has Kubernetes resources manifests under the ",(0,a.kt)("inlineCode",{parentName:"p"},"app/")," directory and it is customized through ",(0,a.kt)("a",{parentName:"p",href:"https://kubectl.docs.kubernetes.io/guides/introduction/kustomize/"},(0,a.kt)("inlineCode",{parentName:"a"},"kustomize"))," for each environment."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"File Structure"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"app\n\u251c\u2500\u2500 base\n\u2502\xa0\xa0 \u251c\u2500\u2500 deployment.yaml\n\u2502\xa0\xa0 \u2514\u2500\u2500 kustomization.yaml\n\u2514\u2500\u2500 overlays\n    \u251c\u2500\u2500 dev\n    \u2502\xa0\xa0 \u2514\u2500\u2500 kustomization.yaml\n    \u2514\u2500\u2500 prod\n        \u2514\u2500\u2500 kustomization.yaml\n"))),(0,a.kt)("p",null,"First, we should create an Application for Argo CD:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Create App"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"argocd app create argocd-demo-prod \\\n    --repo https://github.com/gitploy-io/argocd-demo.git \\\n    --path app/overlays/prod  \\\n    --dest-server https://kubernetes.default.svc \\\n    --dest-namespace argocd \\\n    --sync-policy automated\n"))),(0,a.kt)("p",null,"We should change the Application's revision to the commit SHA. At the same time, we also update the image tag with commit SHA:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Update App"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"argocd app set argocd-demo-prod \\\n    --revision COMMIT_SHA \\\n    --kustomize-image gitployio/argocd-demo=gitployio/argocd-demo:sha-COMMIT_SHA\n"))),(0,a.kt)("p",null,"Finally, We should synchronize the desired state to the Kubernetes cluster:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Sync App"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"argocd app sync argocd-demo-prod --timeout 300\n"))),(0,a.kt)("p",null,"Then, Argo CD continuously synchronizes the manifest of the commit. As a result, the desired manifest and the live state of Kubernetes are always synchronized."),(0,a.kt)("h2",{id:"integration-with-argo-cd"},"Integration With Argo CD"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Demo",src:n(4093).Z,width:"762",height:"352"})),(0,a.kt)("p",null,"Commit pinning is appropriate for production environments, but changing revisions every time is difficult. As a result, many teams (or organizations) adopt HEAD/branch tracking because it is much easier than the commit pinning."),(0,a.kt)("p",null,"But the good thing is that Gitploy can solve this problem easily. Gitploy provides the way to deploy a commit easily, and the deployment event, which is dispatched to CD tooling, includes the commit SHA value. So the CD tool will be able to execute ",(0,a.kt)("inlineCode",{parentName:"p"},"argocd app set")," command with the commit SHA from the deployment event."),(0,a.kt)("p",null,"Below is an example of a pipeline built with Gitploy and GitHub Actions. When Gitploy deploys a commit, it passes the payload including the Application name of the Argo CD to be deployed, and The GitHub Action pipeline accesses ",(0,a.kt)("inlineCode",{parentName:"p"},"github.event.deployment.payload")," to get the Application name. Also, the GitHub Action pipeline gets the commit SHA through the ",(0,a.kt)("inlineCode",{parentName:"p"},"github.sha")," value to deploy."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Gitploy Configuration"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'envs:\n  - name: dev\n    auto_merge: false\n    required_contexts:\n      - "publish-image"\n    payload:\n      application: argocd-demo-dev\n  - name: prod\n    auto_merge: true\n    required_contexts:\n      - "publish-image"\n    production_environment: true\n    payload:\n      application: argocd-demo-prod\n'))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"GitHub Action Pipeline"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'name: deploy\n\non:\n  deployment\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - \n        uses: chrnorm/deployment-status@releases/v2\n        with:\n          deployment-id: ${{ github.event.deployment.id }}\n          description: Trigger the pipeline\n          state: "queued"\n          token: "${{ github.token }}"\n      - \n        uses: chrnorm/deployment-status@releases/v2\n        with:\n          deployment-id: ${{ github.event.deployment.id }}\n          description: Start to deploy to the Kubernetes\n          log-url: https://gitploy.jp.ngrok.io/applications/${{ github.event.deployment.payload.application }}\n          state: "in_progress"\n          token: "${{ github.token }}"\n      - \n        name: Log in\n        uses: clowdhaus/argo-cd-action/@main\n        with:\n          version: 2.3.3\n          command: login gitploy.jp.ngrok.io\n          options: >\n            --username \n            admin \n            --password \n            ${{ secrets.ARGOCD_PASSWORD }}\n      - \n        name: Set image tag\n        uses: clowdhaus/argo-cd-action/@main\n        with:\n          version: 2.3.3\n          command: app set ${{ github.event.deployment.payload.application }}\n          options: >\n            --revision ${{ github.sha }}  \n            --kustomize-image gitployio/argocd-demo=gitployio/argocd-demo:sha-${{ github.sha }}\n      - \n        name: Sync\n        uses: clowdhaus/argo-cd-action/@main\n        with:\n          version: 2.3.3\n          command: app sync ${{ github.event.deployment.payload.application }}\n          options: >\n                        --timeout 300\n      - \n        name: Wait\n        uses: clowdhaus/argo-cd-action/@main\n        with:\n          version: 2.3.3\n          command: app wait ${{ github.event.deployment.payload.application }}\n          options: >\n            --health\n            --timeout 600\n      - \n        if: success()\n        uses: chrnorm/deployment-status@releases/v2\n        with:\n          deployment-id: ${{ github.event.deployment.id }}\n          description: Finish to deploy successfully.\n          log-url: https://gitploy.jp.ngrok.io/applications/${{ github.event.deployment.payload.application }}\n          state: "success"\n          token: "${{ github.token }}"\n      - \n        if: failure()\n        uses: chrnorm/deployment-status@releases/v2\n        with:\n          deployment-id: ${{ github.event.deployment.id }}\n          description: Failed to deploy.\n          log-url: https://gitploy.jp.ngrok.io/applications/${{ github.event.deployment.payload.application }}\n          state: "failure"\n          token: "${{ github.token }}"\n'))),(0,a.kt)("p",null,"Now, when we deploy from Gitploy, we can see that the Argo CD pins the Application to the manifests defined at the specified commit. More details for the demo can be found in this ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gitploy-io"},"repository"),". :)"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Application",src:n(979).Z,width:"1675",height:"358"})))}u.isMDXComponent=!0},979:function(e,t,n){t.Z=n.p+"assets/images/application-a929dc7aec323835a391b780fc8a4153.png"},4093:function(e,t,n){t.Z=n.p+"assets/images/demo-ba818a66c3e051f06c749599804f48bf.gif"}}]);