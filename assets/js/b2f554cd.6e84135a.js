"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1477],{10:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"argocd-commit-pinning","metadata":{"permalink":"/blog/argocd-commit-pinning","editUrl":"https://github.com/gitploy-io/website/tree/main/blog/2022-06-21-argocd-commit-pinning/index.md","source":"@site/blog/2022-06-21-argocd-commit-pinning/index.md","title":"Production Release With Argo CD - Commit Pinning","description":"Gitploy provides another solution deploying to multiple environments.","date":"2022-06-21T00:00:00.000Z","formattedDate":"June 21, 2022","tags":[{"label":"GitHub Action","permalink":"/blog/tags/git-hub-action"},{"label":"Argo CD","permalink":"/blog/tags/argo-cd"},{"label":"Commit Pinning","permalink":"/blog/tags/commit-pinning"}],"readingTime":3.71,"truncated":false,"authors":[],"frontMatter":{"slug":"argocd-commit-pinning","title":"Production Release With Argo CD - Commit Pinning","description":"Gitploy provides another solution deploying to multiple environments.","tags":["GitHub Action","Argo CD","Commit Pinning"],"image":"./demo.gif","keywords":["argocd","argo-cd","commit pinning","deployment strategy"]},"nextItem":{"title":"Deploy to multiple environments with GitHub Action","permalink":"/blog/deploy-to-multi-envs"}},"content":"## Deployment Strategy of Argo CD\\n\\n[Argo CD](https://argo-cd.readthedocs.io/en/stable/) is the most popular\xa0GitOps tool for Kubernetes. Argo CD makes it easy to define an application with its desired state in a repository and where it should be deployed. After a deployment, **Argo CD constantly tracks updates to branches, tags, or pinned to a specific version of manifests at a Git commit.**\\n\\nArgo CD provides [several different ways](https://argo-cd.readthedocs.io/en/stable/user-guide/tracking_strategies/) of tracking Kubernetes resource manifests. Among them, **commit pinning is typically used to control production environments.** Since commit SHAs cannot change the meaning, the live state of an application can be fixed and predictable. So the application remains stable.\\n\\n- HEAD / Branch Tracking\\n- Tag Tracking\\n- Commit Pinning\\n\\n## Commit Pinning By CLI\\n\\nNow, we\'ll deploy the manifest in a specific commit from the Argo CD. First, before starting the demo, install the `argocd` command. More detailed installation instructions can be found via the CLI [installation documentation](https://argo-cd.readthedocs.io/en/stable/cli_installation/).\\n\\nThe [repository](https://github.com/gitploy-io/argocd-demo) to be used as a demo has Kubernetes resources manifests under the `app/` directory and it is customized through [`kustomize`](https://kubectl.docs.kubernetes.io/guides/introduction/kustomize/) for each environment.\\n\\n<details>\\n<summary>File Structure</summary>\\n\\n```shell\\napp\\n\u251c\u2500\u2500 base\\n\u2502\xa0\xa0 \u251c\u2500\u2500 deployment.yaml\\n\u2502\xa0\xa0 \u2514\u2500\u2500 kustomization.yaml\\n\u2514\u2500\u2500 overlays\\n    \u251c\u2500\u2500 dev\\n    \u2502\xa0\xa0 \u2514\u2500\u2500 kustomization.yaml\\n    \u2514\u2500\u2500 prod\\n        \u2514\u2500\u2500 kustomization.yaml\\n```\\n\\n</details>\\n\\nFirst, we should create an Application for Argo CD:\\n\\n<details>\\n<summary>Create App</summary>\\n\\n```shell\\nargocd app create argocd-demo-prod \\\\\\n    --repo https://github.com/gitploy-io/argocd-demo.git \\\\\\n    --path app/overlays/prod  \\\\\\n    --dest-server https://kubernetes.default.svc \\\\\\n    --dest-namespace argocd \\\\\\n\\t--sync-policy automated\\n```\\n\\n</details>\\n\\nWe should change the Application\'s revision to the commit SHA. At the same time, we also update the image tag with commit SHA:\\n\\n<details>\\n<summary>Update App</summary>\\n\\n```shell\\nargocd app set argocd-demo-prod \\\\\\n\\t--revision COMMIT_SHA \\\\\\n\\t--kustomize-image gitployio/argocd-demo=gitployio/argocd-demo:sha-COMMIT_SHA\\n```\\n\\n</details>\\n\\nFinally, We should synchronize the desired state to the Kubernetes cluster:\\n\\n<details>\\n<summary>Sync App</summary>\\n\\n```shell\\nargocd app sync argocd-demo-prod --timeout 300\\n```\\n\\n</details>\\n\\nThen, Argo CD continuously synchronizes the manifest of the commit. As a result, the desired manifest and the live state of Kubernetes are always synchronized.\\n\\n## Integration With Argo CD\\n\\n![Demo](./demo.gif)\\n\\nCommit pinning is appropriate for production environments, but changing revisions every time is difficult. As a result, many teams (or organizations) adopt HEAD/branch tracking because it is much easier than the commit pinning.\\n\\nBut the good thing is that Gitploy can solve this problem easily. Gitploy provides the way to deploy a commit easily, and the deployment event, which is dispatched to CD tooling, includes the commit SHA value. So the CD tool will be able to execute `argocd app set` command with the commit SHA from the deployment event.\\n\\nBelow is an example of a pipeline built with Gitploy and GitHub Actions. When Gitploy deploys a commit, it passes the payload including the Application name of the Argo CD to be deployed, and The GitHub Action pipeline accesses `github.event.deployment.payload` to get the Application name. Also, the GitHub Action pipeline gets the commit SHA through the `github.sha` value to deploy.\\n\\n<details>\\n<summary>Gitploy Configuration</summary>\\n\\n```yaml\\nenvs:\\n  - name: dev\\n    auto_merge: false\\n    required_contexts:\\n      - \\"publish-image\\"\\n    payload:\\n      application: argocd-demo-dev\\n  - name: prod\\n    auto_merge: true\\n    required_contexts:\\n      - \\"publish-image\\"\\n    production_environment: true\\n    payload:\\n      application: argocd-demo-prod\\n```\\n\\n</details>\\n\\n<details>\\n<summary>GitHub Action Pipeline</summary>\\n\\n```yaml\\nname: deploy\\n\\non:\\n  deployment\\n\\njobs:\\n  deploy:\\n    runs-on: ubuntu-latest\\n    steps:\\n      - \\n        uses: chrnorm/deployment-status@releases/v2\\n        with:\\n          deployment-id: ${{ github.event.deployment.id }}\\n          description: Trigger the pipeline\\n          state: \\"queued\\"\\n          token: \\"${{ github.token }}\\"\\n      - \\n        uses: chrnorm/deployment-status@releases/v2\\n        with:\\n          deployment-id: ${{ github.event.deployment.id }}\\n          description: Start to deploy to the Kubernetes\\n          log-url: https://gitploy.jp.ngrok.io/applications/${{ github.event.deployment.payload.application }}\\n          state: \\"in_progress\\"\\n          token: \\"${{ github.token }}\\"\\n      - \\n        name: Log in\\n        uses: clowdhaus/argo-cd-action/@main\\n        with:\\n          version: 2.3.3\\n          command: login gitploy.jp.ngrok.io\\n          options: >\\n            --username \\n            admin \\n            --password \\n            ${{ secrets.ARGOCD_PASSWORD }}\\n      - \\n        name: Set image tag\\n        uses: clowdhaus/argo-cd-action/@main\\n        with:\\n          version: 2.3.3\\n          command: app set ${{ github.event.deployment.payload.application }}\\n          options: >\\n            --revision ${{ github.sha }}  \\n            --kustomize-image gitployio/argocd-demo=gitployio/argocd-demo:sha-${{ github.sha }}\\n      - \\n        name: Sync\\n        uses: clowdhaus/argo-cd-action/@main\\n        with:\\n          version: 2.3.3\\n          command: app sync ${{ github.event.deployment.payload.application }}\\n          options: >\\n\\t\\t\\t\\t\\t\\t--timeout 300\\n      - \\n        name: Wait\\n        uses: clowdhaus/argo-cd-action/@main\\n        with:\\n          version: 2.3.3\\n          command: app wait ${{ github.event.deployment.payload.application }}\\n          options: >\\n            --health\\n            --timeout 600\\n      - \\n        if: success()\\n        uses: chrnorm/deployment-status@releases/v2\\n        with:\\n          deployment-id: ${{ github.event.deployment.id }}\\n          description: Finish to deploy successfully.\\n          log-url: https://gitploy.jp.ngrok.io/applications/${{ github.event.deployment.payload.application }}\\n          state: \\"success\\"\\n          token: \\"${{ github.token }}\\"\\n      - \\n        if: failure()\\n        uses: chrnorm/deployment-status@releases/v2\\n        with:\\n          deployment-id: ${{ github.event.deployment.id }}\\n          description: Failed to deploy.\\n          log-url: https://gitploy.jp.ngrok.io/applications/${{ github.event.deployment.payload.application }}\\n          state: \\"failure\\"\\n          token: \\"${{ github.token }}\\"\\n```\\n\\n</details>\\n\\nNow, when we deploy from Gitploy, we can see that the Argo CD pins the Application to the manifests defined at the specified commit. More details for the demo can be found in this [repository](https://github.com/gitploy-io). :)\\n\\n![Application](./application.png)"},{"id":"deploy-to-multi-envs","metadata":{"permalink":"/blog/deploy-to-multi-envs","editUrl":"https://github.com/gitploy-io/website/tree/main/blog/2022-03-10-deploy-to-multi-envs/index.md","source":"@site/blog/2022-03-10-deploy-to-multi-envs/index.md","title":"Deploy to multiple environments with GitHub Action","description":"Gitploy provides another solution deploying to multiple environments.","date":"2022-03-10T00:00:00.000Z","formattedDate":"March 10, 2022","tags":[{"label":"GitHub Action","permalink":"/blog/tags/git-hub-action"},{"label":"Multiple Environments","permalink":"/blog/tags/multiple-environments"}],"readingTime":2.675,"truncated":false,"authors":[],"frontMatter":{"slug":"deploy-to-multi-envs","title":"Deploy to multiple environments with GitHub Action","description":"Gitploy provides another solution deploying to multiple environments.","tags":["GitHub Action","Multiple Environments"],"image":"./demo.gif","keywords":["deploy","multiple environments","different environments","github action"]},"prevItem":{"title":"Production Release With Argo CD - Commit Pinning","permalink":"/blog/argocd-commit-pinning"}},"content":"Having a well-tuned workflow keeps a team productive and helps them deliver reliable software. One recommended practice for any significant software development is using multiple environments. Using multiple environments ensures that software is rigorously tested before deployed and made available to users.\\n\\nA general way for deploying to an environment is the branch strategy. Users create branches for each environment and deploy them by pushing a commit to the branch. Then, The deployment tool such as GitHub Action or Circle CI will deploy to the environment corresponding to the branch name.\\n\\nThe following is an example that deploy to the Azure Function App by a GitHub Action. Firstly, it wants to trigger the workflow on push events for specific branches such as `dev`, `staging` and `prod`. And in the `steps`, through the `if` syntax, the workflow deploys it to a different environment for each branch.\\n\\n<details>\\n<summary>Deploy By Branch Push</summary>\\n\\n```yaml title=\\".github/workflows/deploy-by-branch.yaml\\"\\non:\\n  push:\\n    branches:\\n      - dev\\n      - staging\\n      - prod\\n\\njobs:\\n  deploy:\\n    runs-on: ubuntu-latest\\n    steps:\\n      - \\n        name: Set env vars for dev\\n        if: github.ref_name == \'dev\'\\n        run: |\\n          echo \\"AZURE_FUNCTIONAPP_NAME=gitploy-dev\\" >> $GITHUB_ENV\\n          echo \\"PUBLISH_PROFILE_VAR_NAME=AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV\\" >> $GITHUB_ENV\\n      - \\n        name: Set env vars for prod\\n        if: github.ref_name == \'prod\'\\n        run: |\\n          echo \\"AZURE_FUNCTIONAPP_NAME=gitploy-prod\\" >> $GITHUB_ENV\\n          echo \\"PUBLISH_PROFILE_VAR_NAME=AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD\\" >> $GITHUB_ENV\\n      - \\n        uses: Azure/functions-action@v1\\n        with:\\n          app-name: ${{ env.AZURE_FUNCTIONAPP_NAME }}\\n          publish-profile: ${{ secrets[env.PUBLISH_PROFILE_VAR_NAME] }}\\n          respect-funcignore: true\\n```\\n</details>\\n\\n**However, although the branch strategy is easy and fast, it is not flexible and scalable.** The user must create a new branch and modify the workflow if a new environment is added.\\n\\nOn the other hand, Gitploy provides another solution. **Gitploy dispatches an event that includes information necessary for deployment, such as the environment name, Function App name, and so on, through the [deployment API](https://docs.github.com/en/rest/reference/deployments#deployments).** \\n\\nTo activate Gitploy, we should place the `deploy.yml` file in the root of the git repository like below. Note that the `payload` field has the informations for deployment, and it has different information for each environment, respectively. When a user triggers, the `payload` is passed to the deployment tooling.\\n\\n<details>\\n<summary>deploy.yml</summary>\\n\\n```yaml title=\\"deploy.yml\\"\\nenvs:\\n  - name: dev\\n    auto_merge: false\\n    payload:\\n      AZURE_FUNCTIONAPP_NAME: gitploy-dev\\n      PUBLISH_PROFILE_VAR_NAME: AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV\\n  - name: prod\\n    auto_merge: false\\n    payload:\\n      AZURE_FUNCTIONAPP_NAME: gitploy-prod\\n      PUBLISH_PROFILE_VAR_NAME: AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD\\n```\\n\\n</details>\\n\\nAnd in the workflow, the information for deployment is read through the `github.event.deployment.payload` context so that the workflow does not need `if` syntax for conditional steps anymore.\\n\\n<details>\\n<summary>Deploy By Gitploy</summary>\\n\\n```yaml title=\\".github/workflows/deploy-by-gitploy.yaml\\"\\non:\\n  deployment\\n\\njobs:\\n  deploy:\\n    runs-on: ubuntu-latest\\n    steps:\\n      - \\n        uses: chrnorm/deployment-status@releases/v1\\n        with:\\n          deployment_id: ${{ github.event.deployment.id }}\\n          description: Start to deploy.\\n          state: \\"in_progress\\"\\n          token: \\"${{ github.token }}\\"\\n\\n      - \\n        uses: Azure/functions-action@v1\\n        with:\\n          app-name: ${{ github.event.deployment.payload[\'AZURE_FUNCTIONAPP_NAME\'] }}\\n          publish-profile: ${{ secrets[github.event.deployment.payload[\'PUBLISH_PROFILE_VAR_NAME\'] }}\\n          respect-funcignore: true\\n      \\n      - \\n        if: success()\\n        uses: chrnorm/deployment-status@releases/v1\\n        with:\\n          deployment_id: ${{ github.event.deployment.id }}\\n          description: Success to deploy.\\n          state: \\"success\\"\\n          token: \\"${{ github.token }}\\"\\n      - \\n        if: failure()\\n        uses: chrnorm/deployment-status@releases/v1\\n        with:\\n          deployment_id: ${{ github.event.deployment.id }}\\n          description: Failed to deploy.\\n          state: \\"failure\\"\\n          token: \\"${{ github.token }}\\"\\n```\\n\\n</details>\\n\\nFinally, when you trigger on Gitploy, you can see that it successfully deploys to the environment. \ud83d\ude80 \\n\\n![Demo](./demo.gif)\\n\\n*Thanks for reading, and stay tuned for a more good read. If you have a question, please post questions or comments to our [community](https://github.com/gitploy-io/gitploy/discussions)*\\n\\n**Reference**\\n\\n* [Github Actions: deploy to multiple environments from single workflow](https://www.maxivanov.io/github-actions-deploy-to-multiple-environments-from-single-workflow/)\\n* Demo: [gitploy-io/multi-env-demo](https://github.com/gitploy-io/multi-env-demo)"}]}')}}]);